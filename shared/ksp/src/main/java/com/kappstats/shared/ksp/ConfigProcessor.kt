package com.kappstats.shared.ksp

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.KSAnnotated
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import java.io.File

class ConfigProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val gitBranch: String?,
    private val projectDir: String?
) : SymbolProcessor {

    private var isInvoked = false
    private val packageName = "com.kappstats.constants.config"
    private val kspMetadataDir = "build/generated/ksp/metadata/commonMain/kotlin/"

    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (isInvoked) return emptyList()
        isInvoked = true
        gitBranch?.let { branch ->
            generateBuildConfigClass(
                branch
            )
        }
        projectDir?.let { dir ->
            generateEnvConfig(dir)
        }
        return emptyList()
    }

    private fun generateBuildConfigClass(
        branch: String
    ) {
        val fileName = "ProjectConfig"
        generateObjectForConstVal(
            filename = fileName,
            packageName = packageName,
            kspMetadataDir = kspMetadataDir,
            values = mapOf("GIT_BRANCH" to branch)
        )
    }

    private fun generateEnvConfig(
        projectDir: String
    ) {
        val envFile = File("$projectDir/.env")
        if (envFile.exists()) {
            val envVars = if (envFile.exists()) {
                envFile.readLines().mapNotNull { line ->
                    val trimmed = line.trim()
                    if (trimmed.isNotEmpty() && !trimmed.startsWith("#") && "=" in trimmed) {
                        val (key, value) = trimmed.split("=", limit = 2)
                        key.trim() to value.trim().removeSurrounding("\"")
                    } else null
                }.toMap()
            } else emptyMap()
            println("EnvVars:")
            val fileName = "EnvConfig"
            generateObjectForConstVal(
                filename = fileName,
                packageName = packageName,
                kspMetadataDir = kspMetadataDir,
                values = envVars
            )
        }
    }

    private fun generateObjectForConstVal(
        filename: String,
        packageName: String,
        kspMetadataDir: String,
        values: Map<String, String>
    ) {
        val configClass = TypeSpec.objectBuilder(filename)
            .addKdoc("Auto-generated by Gradle. Do not edit manually.")
        values.forEach { value ->
            println("${value.key} = ${value.value}")
            configClass.addProperty(
                PropertySpec.builder(value.key, String::class)
//                    .addModifiers(KModifier.CONST)
                    .initializer("%S", value.value)
                    .build()
            )
        }
        val configTypeSpec = configClass.build()
        val fileSpec = FileSpec.builder(
            packageName = packageName,
            fileName = filename
        ).addType(configTypeSpec).build()
        val packagePath = packageName.replace('.', '/')
        val moduleRoot = File("shared")
        val fileToDelete =
            File(moduleRoot, "$kspMetadataDir$packagePath/$filename.kt")
        if (fileToDelete.exists()) {
            val deleted = fileToDelete.delete()
            if (deleted) {
                logger.logging("Old file $filename.kt deleted.")
            } else {
                logger.error("Delete $filename.kt error.", null)
            }
        }
        val dependencies = Dependencies(aggregating = false, sources = emptyArray())
        val outputStream = codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = packageName,
            fileName = filename
        )
        outputStream.use { stream ->
            val writer = stream.writer()
            fileSpec.writeTo(writer)
            writer.flush()
        }
    }
}